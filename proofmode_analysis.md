# ProofMode Analysis and Verification Guide

## Overview and Core Technologies

**Note: General Overview**
ProofMode is a sophisticated system for verifying the authenticity of media files (photos and videos) using multiple layers of cryptographic verification. It combines several technologies:
- Digital signatures (OpenPGP)
- Cryptographic hashing (SHA-256)
- Blockchain timestamping (OpenTimestamps)
- Device attestation (Google SafetyNet)

The system creates a "proof" package that can be used to verify that a media file hasn't been tampered with and was captured on a specific device at a specific time.

---

## Verification Methods

### Web-Based Verification

**Note: Web Tool**
ProofMode provides a web-based tool called ProofCheck that simplifies the verification process. This is the user-friendly way to verify media files, but understanding the manual process helps understand what's happening under the hood.

Tools and guides for media verification

Assisted Verification
We have released our ProofCheck Web Tool that makes it easy to inspect any photo or video, and help verify any proof zip generated by a recent ProofMode app. Learn more about it on the project page.

### Manual Verification Process

Manual Verification
Brief information on how to verify the media file, proof and signatures contained in a ProofMode ZIP file. The steps below currently only cover the INTEGRITY verification that is the first step of our Three Layer Verification Process.

**Note: Three Layer Verification**
The system appears to use a three-layer verification process:
1. Integrity verification (ensuring the file hasn't been modified)
2. Device verification (ensuring it came from a specific device)
3. Timestamp verification (ensuring when it was created)

You can learn more about the specific metadata fields available on the Metadata Documentation page.

## Platform-Specific Instructions

### Linux Implementation

**Note: Command Line Tools**
The verification process uses standard cryptographic tools:
- GPG: For digital signature verification
- SHA256: For file integrity checking
- JQ: For parsing JSON data
These are all open-source tools commonly used in security applications.

Requirements
install gpg, sha256sum, jq using your operating system package manager

Steps
Import public key shared from ProofMode:
Don't know what a "Public Key" is? Learn more on this web-based tutorial from varonis.com

**Note: Public Key Cryptography**
The system uses public key cryptography, where:
- The sender (ProofMode app) has a private key
- The verifier uses the corresponding public key
- This ensures only the original sender could have created the signature

ProofMode relies on the open standard of Open Pretty Good Privacy, or OpenPGP, for its public key cryptography. The toolkit that we recommend for verifying the digital signatures within the ProofMode zip file is GnuPG aka gpg, a free and open-source software package.

```bash
gpg --import pubkey.asc
gpg: key xxx: public key "noone@proofmode.witness.org" imported
gpg: Total number processed: 1
gpg:               imported: 1
```

### Hash Verification Process

**Note: Hash Verification**
The SHA-256 hash acts as a unique fingerprint for the file. Any modification to the file, no matter how small, will result in a completely different hash. This is crucial for detecting tampering.

Check the hash of the media file against the hash in the proof metadata
A hash is another name for a "SHA256 Checksum". A SHA-256 checksum is a sequence of numbers and letters that you can use to check that your copy of a downloaded update file is identical to the original. Small changes in a file produce very different looking checksums. You can also use a checksum to help verify that an attacker has not made changes to a file.

If you know the checksum of the original file, you can run a checksum or hashing utility on it. If the resulting checksum matches, you know the file you have is identical.

```bash
sha256sum YOURMEDIAFILE.jpg
THEHASHVALUEFORYOURPHOTO  YOURMEDIAFILE.jpg
```

### Signature Verification Process

**Note: Signature Verification**
The signature verification process confirms that:
1. The file hasn't been modified (hash matches)
2. The file was actually signed by the ProofMode app (signature is valid)
3. The metadata about the file is authentic (proof file signature)

Running the above command will give you the sha256 checksum, or "hash", that is the key to connecting the media file to the proofmode data in the proof zip. Using the THEHASHVALUEFORYOURPHOTO indicated above, you can now look for files names THEHASHVALUEFORYOURPHOTO.csv, THEHASHVALUEFORYOURPHOTO.json, and so on within the proof zip. If you can't find any files matching THEHASHVALUEFORYOURPHOTO, then the original media file was manipulated somehow.

Verify signature using actual photo to test GOOD signature
```bash
gpg --dearmor pubkey.asc
gpg --no-default-keyring --keyring ./pubkey.asc.gpg --homedir ./ --verify THEHASHVALUEFORYOURPHOTO.asc YOURMEDIAFILE.jpg

gpg: Signature made Thu 03 Feb 2022 10:51:16 PM EST
gpg:                using RSA key 560CC828C726365F
gpg: Good signature from "noone@proofmode.witness.org" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 094F 9BAE 1895 8C23 8F55  F793 560C C828 C726 365F
```

## Blockchain Integration

### OpenTimestamps Implementation

**Note: Blockchain Timestamping**
OpenTimestamps provides a way to prove that the file existed at a specific time by creating a cryptographic proof that's eventually recorded on the Bitcoin blockchain. This is useful for proving the file wasn't created after a certain date.

**Note: Bitcoin Network Integration Details**
The use of the Bitcoin blockchain for timestamping provides several key benefits:
1. Immutable Proof: Once a timestamp is recorded in a Bitcoin block, it cannot be altered or deleted
2. Decentralized Trust: No single entity controls the timestamping process
3. Public Verification: Anyone can verify the timestamp without special access
4. Cost-Effective: Uses existing Bitcoin infrastructure without requiring additional blockchain development
5. Time-Stamped Chain: Each block is linked to the previous one, creating an unbroken chain of timestamps

The process works by:
1. Creating a cryptographic hash of the file
2. Submitting this hash to OpenTimestamps servers
3. OpenTimestamps creates a Merkle tree of multiple hashes
4. The root of this tree is eventually recorded in a Bitcoin transaction
5. This creates a proof that the file existed before the Bitcoin block was mined

If you see "Good signature" as in the sample output above, then all is well! You can also see the time and date that the signature was made.

The above "WARNING" is simply saying that the key provided in the proof is not one that has been reviewed and verified by a third-party. This is normal for public keys that are generated as part of ProofMode.

### Additional Signature Verification

Verify signature of ProofMode data using actual media file to test GOOD signature

This command is similar to the one used for verifying the integrity of the media file, but is instead being run on the CSV proof data file.

```bash
gpg --verify THEHASHVALUEFORYOURPHOTO.proof.csv.asc THEHASHVALUEFORYOURPHOTO.proof.csv
gpg: Signature made Thu 03 Feb 2022 10:51:18 PM EST
gpg:                using RSA key 560CC828C726365F
gpg: Good signature from "noone@proofmode.witness.org" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 094F 9BAE 1895 8C23 8F55  F793 560C C828 C726 365F
```

## Device Verification

### Google SafetyNet Integration

**Note: Device Attestation**
Google SafetyNet provides device-level attestation, which helps verify that the media was captured on a legitimate Android device that hasn't been rooted or modified. This adds another layer of trust to the verification process.

Again, you are looking for the "Good signature" output from the command.

Verify the OpenTimestamps notarization
If a .OTS file is present, you can visit opentimestamps.org to learn more about how to upload the file to verify the notarization. It can take awhile for the notarization timestamp to make its way fully to the Bitcoin blockchain.

You can also do command line verification using the opentimestamps-client.

```bash
pip3 install opentimestamps-client
ots -v v THEHASHVALUEFORYOURPHOTO.ots -f YOURMEDIAFILE.jpg
```

The output will validate the OpenTimestamps notarization and tell you the status of its propagation onto the Bitcoin Blockchain.

As long as you see attestations from the servers associated with the Opentimestamps service, then integrity of the notarization of this proof is validated.

### SafetyNet Verification Process

Verify the Google SafetyNet attestation
If a .GST file is present, that is a Javascript Web Token signature from Google SafetyNet notarization. You can decode the value of it for inspection at jwt.io.

Learn how the SafetyNet Attestation API provides a cryptographically-signed attestation, assessing the integrity of the Android device your app is running on.

You can also decide the GST file, using the command below

```bash
jq -R 'split(".") | select(length > 0) | .[0],.[1] | @base64d | fromjson' <<< cat THEHASHVALUEFORYOURPHOTO.gst
```

The output will display the values related to the attestation provided by Google's service. It includes information verifying the integrity of the device the media was captured on, as well as date and time information.

**Note: Google SafetyNet Deep Dive**
Google SafetyNet provides a robust device attestation system that:
1. Hardware-Level Verification:
   - Checks if the device's hardware is genuine
   - Verifies the bootloader hasn't been tampered with
   - Confirms the device hasn't been rooted

2. Security Features:
   - Uses hardware-backed attestation when available
   - Implements anti-tampering measures
   - Provides real-time device integrity checks

3. JWT (JSON Web Token) Structure:
   - Header: Contains algorithm and key information
   - Payload: Includes device integrity data, timestamp, and nonce
   - Signature: Cryptographically signed by Google's servers

4. Integration Benefits:
   - Helps prevent "deep fake" media creation on compromised devices
   - Provides timestamp of when the media was captured
   - Adds an additional layer of trust to the verification process

5. Limitations:
   - Currently only available on Android devices
   - Requires Google Play Services
   - May not be available in all regions

## Automation and Cross-Platform Support

### Automation Tools

**Note: Automation**
The system provides scripts to automate the verification process, making it easier to verify multiple files or integrate into other systems.

Automating verification of proof data
You can find a verify.sh script work-in-progress here

### MacOS Implementation

**Note: Cross-Platform Support**
The verification process can be performed on any major operating system, with slight variations in command syntax. This makes the system widely accessible.

The same steps above from the Linux section can be completed on a MacOS computer using the Terminal app. You may need to install GPG and sha256sum tools using Homebrew or MacPorts.

On a Mac, the command is "shasum -a 256" instead "sha256sum"

Install GPG on Mac without GPG Tools

You can also use any graphical or web-based PGP or Sha256 utility available on MacOS.

GPGTools for Mac

### Windows Implementation

**Note: Windows Implementation**
Windows users can either use WSL (Windows Subsystem for Linux) to run the Linux commands directly, or use Windows-native tools that provide similar functionality.

The same steps above from the Linux can be complete usins the Windows Subsystem for Linux.

You can also use any graphical or web-based PGP or Sha256 utility available on Windows.

GnuPG Downloads

Verify SHA 256 Checksums with Windows Powershell 

## Modern Implementation: EAS and Merkle Tree Design

### Overview

**Note: Modern Implementation**
This section outlines a modern implementation approach using Ethereum Attestation Service (EAS) and Merkle trees, which provides a more efficient and flexible way to verify media authenticity.

### Proof Document Structure

```json
{
    "header": {
        "alg": "ES256K-KECCAK256",
        "typ": "JWS"
    },
    "payload": {
        "merkleTree": {
            "header": {
                "alg": "SHA256",
                "typ": "MerkleTree+1.0"
            },
            "leaves": [
                {
                    "data": "iVBORw0KGgoAAAANSUhEUgAA...", // Base64 encoded image data
                    "salt": "0x...", // Random salt for the image
                    "hash": "0x...", // SHA256(image + salt)
                    "contentType": "image/jpeg; encoding=base64"  // Matches the base64 encoding
                },
                {
                    "data": "0x...", // Complete SafetyNet JWT
                    "salt": "0x...", // Random salt for the JWT
                    "hash": "0x...", // SHA256(JWT + salt)
                    "contentType": "application/jwt"
                },
                {
                    "data": {
                        "imageMetadata": {
                            "timestamp": "2024-03-21T12:00:00Z",
                            "exif": {
                                "make": "Google",
                                "model": "Pixel 6",
                                "software": "Android 14",
                                "exposureTime": "1/125",
                                "fNumber": "2.0",
                                "iso": "100",
                                "focalLength": "4.44",
                                "flash": "No Flash",
                                "gps": {
                                    "latitude": 51.5074,
                                    "longitude": -0.1278,
                                    "altitude": 35.5
                                }
                            },
                            "dimensions": {
                                "width": 4032,
                                "height": 3024
                            },
                            "format": "JPEG",
                            "size": 5242880
                        }
                    },
                    "salt": "0x...",
                    "hash": "0x...",
                    "contentType": "application/json"
                }
            ],
            "root": "0x..." // Merkle root of all leaves
        },
        "attestation": {
            "eas": {
                "network": "base-sepolia",
                "attestationUid": "0x...",
                "from": "0x...", // Device address
                "to": "0x...",   // Optional recipient
                "schema": {
                    "schemaUid": "0x...",
                    "name": "ProofModeAttestation"
                }
            }
        },
        "timestamp": "2024-03-21T12:01:00Z", // When the proof was created
        "proofTimestamp": "2024-03-21T12:01:05Z" // When the EAS attestation was created
    },
    "signature": "0x..." // Signature of the entire document
}
```

### Key Components

**Note: Document Structure**
The proof document consists of several key components:
1. JWS header for document signing
2. Merkle tree containing all verification data
3. EAS attestation for on-chain verification
4. Multiple timestamps for different stages
5. Overall document signature

### Verification Data

**Note: Leaf Structure**
Each leaf in the Merkle tree contains:
1. Image data with capture metadata
2. Complete SafetyNet JWT for device verification
3. Rich image metadata including:
   - Capture timestamp
   - EXIF data (camera settings, GPS)
   - Technical specifications
   - File information

### Timestamps

**Note: Temporal Verification**
The document includes three distinct timestamps:
1. Image capture time (in metadata)
2. Proof creation time
3. EAS attestation time

This creates a clear chain of events and helps establish the timeline of the verification process.

### Benefits

**Note: Implementation Advantages**
This modern implementation provides several benefits:
1. Efficient verification through Merkle proofs
2. On-chain attestation via EAS
3. Rich metadata for comprehensive verification
4. Clear temporal chain of events
5. Flexible structure for future extensions

### Security Features

**Note: Security Considerations**
The implementation includes several security features:
1. Salts for each leaf to prevent rainbow table attacks
2. JWS signature for document integrity
3. Merkle tree for efficient verification
4. EAS attestation for on-chain verification
5. Complete device attestation via SafetyNet

This modern implementation maintains all the security features of the original ProofMode while adding the benefits of blockchain-based verification and efficient Merkle proofs. 