# ERC-7702 - Set Code for EOAs
## Add a new tx type that permanently sets the code for an EOA

**Note** - I seemed to have originally written this up from possibly an old version of the proposal, see below. The current version has a completely different title and my notes below don't rhyme well with the EIP itself. 

Requires	EIP-2, EIP-161, EIP-1052, EIP-2718, EIP-2929, EIP-2930, EIP-3541, EIP-3607, EIP-4844

[Link to EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)

 - A new EIP-2718 transaction type which is processed as an instruction to set the 'code' on their EOA account on the blockchain.
 - All Ethereum accounts have a slot for code, which is only used for Smart Contract addresses where it is a hash of the code.
 - Thus, EOAs have an unused slot.
 - The new transaction type contains a list of tuples containing the chain ID and address of the contract they would like to use as their EOA Smart Contract account code, plus a nonce and vrs signature.
 - For each tuple a special delegation indicator is written to the code slot, `[0xef0100 || address]`.
 - "All code executing operations must load and execute the code pointed to by the delegation." which I think means EVM opcodes like `CALL` etc.
 - I think there is no new transaction but just like contract-to-contract behaviour, a new call frame starts for the execution of the code pointed to in the delegation.
 - The `msg.sender` is contract A or perhaps another EOA or the EOA themselves, but if they make onward calls to other contracts (or other smart hybrid EOAs) then the `msg.sender` will be the EOA.
 - I think this is the key unlock: the EOA can run code. But it is confusing because the EOA could run code anyway, so perhaps the unlock is simply that EOAs have functions. Wait. Hang on...
 - The motivations cite all kinds of possibilities such as batch transactions, so why was this not possible before? Well, can EOA must sign every transaction to run code. If they ran some code in contract called Batcher which then issued e.g. an `erc20.Approve(auction)` and a `auction.Bid(...)` then the message sender would be Batcher, so that won't work. But...
 - If the batching was code running in the context of the EOA, then those two calls would have a `msg.sender` of the EOA! Yay.
 - I think this means an outside contract can call a function on your EOA which then batches transactions, which seems dodgy but your EOA could store permissions or signed auth slips to allow other callers to run that code, which then runs as your EOA.

## From ChatGPT

You‚Äôve got it right. Let‚Äôs walk it step by step.

---

### Scenario

* **A** = contract making the call
* **Z** = EOA with a 7702 delegation pointing to **B** (delegation contract)
* **B** = code that Z has delegated to
* **C** = some third contract

---

### Step 1: `A ‚Üí Z`

* A executes `CALL` to Z.
* EVM checks: Z has a delegation.
* EVM loads B‚Äôs code but executes it **in Z‚Äôs context**.
* Inside B:

  * `msg.sender == A`
  * `address(this) == Z`
  * storage/balance belong to Z

So far, it‚Äôs identical to a normal contract call, except that Z‚Äôs code comes from the delegation pointer.

---

### Step 2: `Z (running B‚Äôs code) ‚Üí C`

* If B‚Äôs code executes a `CALL` to C:

  * The caller is Z (the account whose frame is active).
  * `msg.sender` in C will be Z.
  * Any ETH sent comes from Z‚Äôs balance.

---

### Analogy

It‚Äôs basically as if Z had directly installed B‚Äôs bytecode as its account code. The indirection (‚Äúdelegation‚Äù) only changes *where the code is fetched from*, not how the call semantics work.

---

üëâ So yes:

* `msg.sender = A` when A calls into Z (delegation via B).
* `msg.sender = Z` when the delegated code makes a call onward to C.

---

Do you want me to also spell out how this differs from a world where A called B directly? That‚Äôs where some subtle UX/security differences show up.





# ERC-7702 - Transaction Precondition Predicates for EOAs

[Link to EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)

**Conceptual Summary**: ERC-7702 enables transaction precondition predicates that execute under EOA impersonation. In plain terms, it lets an Externally Owned Account (EOA) attach validation logic‚Äîlike spending limits or multisig checks‚Äîto a transaction, running this logic in the EOA‚Äôs context (as if the EOA were a smart contract) before the transaction‚Äôs main action (e.g., a transfer) proceeds.

**Requires**: 
- EIP-1559 (for modern gas pricing, assumed in transaction format).
- EIP-2718 (Typed Transaction Envelope, to define the new transaction type).
- No other EIPs are strict dependencies, but aligns with EIP-4337 (Account Abstraction) for synergy.

## Official Explainer

**EIP-7702**, authored by Vitalik Buterin and others, introduces a new Ethereum transaction type that enhances Externally Owned Accounts (EOAs) with programmable validation, a step toward native account abstraction. It allows an EOA to specify precondition predicates‚Äîcustom logic executed in the EVM‚Äîbefore a transaction‚Äôs payload (e.g., ETH transfer or contract call) is processed. This logic runs in the context of the EOA‚Äôs address (`msg.sender` is the EOA), enabling smart contract-like behavior without deploying a persistent contract.

### How It Works
- **New Transaction Type**: Defined under EIP-2718, ERC-7702 transactions include standard fields (`chainId`, `nonce`, `to`, `value`, `data`, etc.) plus an `authorization_list`.
- **Authorization List**: A list of `Authorization` objects, each containing:
  - `contract_code` (optional): Bytecode to execute as the EOA‚Äôs logic for this transaction.
  - `authority`: Address of a contract to call for validation (alternative to `contract_code`).
  - `parameters`: Calldata to invoke the validation logic (e.g., calling a `validate` function).
- **Execution Flow**:
  1. For each `Authorization` in the `authorization_list`:
     - If `contract_code` is provided, the EVM executes it as if it were the EOA‚Äôs code, with `msg.sender` as the EOA‚Äôs address.
     - If `authority` is used, the EVM calls the contract with `parameters` (e.g., `validate(address,bytes,uint256)`).
     - The validation must return `true` (0x01) for the transaction to proceed; otherwise, it reverts.
  2. If all validations pass, the EVM executes the main transaction (`to`, `value`, `data`).
- **No Persistent State**: Unlike deploying a contract, ERC-7702‚Äôs logic is transient‚Äîvalid only for that transaction, leaving the EOA unchanged.

### Key Facts
- **Backward Compatibility**: Existing EOAs can use ERC-7702 without migration, as it‚Äôs opt-in via the transaction type. Regular transactions (e.g., EIP-1559) are unaffected.
- **Replaces EIP-3074**: ERC-7702 supersedes EIP-3074, which allowed EOAs to delegate to invoker contracts but had security flaws (e.g., replay risks). ERC-7702‚Äôs per-transaction logic is safer and more flexible.
- **Use Cases**: Enables gasless transactions (via paymasters), batched calls (e.g., approve + swap), custom permissions (e.g., daily limits), and multisig-like security, all natively for EOAs.

## Notes
- **Relation to Pectra**: ERC-7702 is part of the Pectra hard fork (2025), requiring EVM changes to process the new transaction type.
- **Security**: Validation contracts must be audited, as bugs could allow unauthorized actions. The boolean return (`true`) ensures clear validation.
- **Synergy with Standards**: Works with ERC-4337 (bundlers) and ERC-5792 (batched calls), enhancing wallet UX (e.g., MetaMask‚Äôs ‚ÄúGator‚Äù framework).

**Nuance on ‚ÄúImpersonation‚Äù**: The term ‚Äúimpersonation‚Äù in the summary suggests the EOA pretends to be something else, but technically, the validation runs with the EOA as `msg.sender`. A more precise phrasing might be ‚Äúin the EOA‚Äôs context,‚Äù though the original captures the intent for quick understanding.
